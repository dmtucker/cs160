1. You have a 3D scene which includes an apartment building with a flat, rectangular window. The corners of the window are at:

 [-1, 10, -2],   [-1, 10, 2],  [1, 10, 2],  and [1, 10, -2]

You want to set up the camera such that it is looking into the apartment through the window. In particular, you want the projection plane of the camera to coincide exactly with the window and you want the camera position to be at [0, 5, 0].

Fill in the parameters for calls to gluLookAt and glFrustrum that achieve the desired camera position. Assume that glFrustrum will be called with the projection matrix stack active while gluLookAt will be called with the model view matrix stack active before a call to "draw_apartment" which will draw the scene.


gluLookAt(
  0, 5, 0, // from this point
  0, 10, 0, // at this point
  0, 0, 1 // up vector (doesn't matter for this problem)
);

glFrustrum(
  -1, 1, // left and right
  -2, 2, // bottom and top
  5, // near (setting this to the distance from the camera to the window is key)
  100 // far (doesn't matter for this problem)
)


2. You want to enable the depth buffer in your program so you find an online tutorial that shows you how. The tutorial has the following steps:

  I. Make sure that you're passing the GLUT_DEPTH flag to glutInitDisplayMode.

  II. In your setup code, call glEnable(GL_DEPTH_TEST), glClearDepth(0.0) and glDepthFunc(GL_GREATER).

  III. At the beginning of your drawing code, clear the depth buffer along with the color buffer using glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT).

After following these directions, you find that your scene still renders, but that now objects farther away from the camera are always being drawn on top of closer objects regardless of drawing order.

a) You immediately notice that the call to glDepthFunc seems wrong. You change it to glDepthFunc(GL_LESS) in hopes of fixing your scene but that doesn't work. Describe what you do see after changing the glDepthFunc call in this way.

A black screen (because nothing has a depth value of less than 0.0).

b) After your change to the glDepthFunc call, what additional change do you need to get a correct depth buffer? Indicate which function call you change and what the new parameter(s) are.

Change glClearDepth(0.0) to glClearDepth(1.0);


3. You want to draw a single stained-glass window in an OpenGL scene that will look translucent. Your scene is using the depth buffer to handle occlusion, and the window polygon is set up to use alpha blending (i.e. it will take some fraction of the existing color and mix it with a predefined tint color when it is rendered instead of just replacing the existing pixel values with new values like a normal object would).

a) To render the stained-glass window correctly allowing objects behind it to show through, which strategy should you use?

  I. Render the window polygon first with the depth buffer turned off and then render the rest of the scene.

  II. Render the window polygon normally along with other scene objects while the depth buffer is turned on.

  III. Render the window polygon in a separate pass after rendering the rest of the scene.

Explain your choice.


III is correct, because the window needs to know the colors of all objects behind it in order to render correctly. In cases I and II, an object behind the window might be rendered after the window is, which will produce the wrong color.


b) Does the solution that you chose in part (a) work if there are multiple windows that might overlap from the camera's perspective? If not, do any of the options in part a work in this case?

None of the options from part a work in the multiple-window case, because the windows might overlap each other. Some variation of the painter's algorithm (or some other more clever solution) is needed in this case.



4. For each situation below, specify whether a lighting model would need just ambient lighting, ambient + diffuse lighting, ambient + diffuse + specular lighting, or some even more advanced lighting technique for acceptable rendering. Don't worry about whether shadows would be needed or what type(s) of light source are required, just think about the rendering of individual surfaces in the scene. Justify your answers.

a) A scene for a simple cellphone game involving matte spheres and a single stationary light source.

Ambient + diffuse lighting. Specular lighting is not needed as the spheres aren't shiny.


b) A scene set in a room with a mirror in it that shows a reflection of the room including a single overhead light source.

A more advanced technique is required to render the mirror's reflection.


c) A pool table scene involving both matte playing surfaces (felt and wood) as well as shiny (but not mirrored) balls that should reflect light from multiple sources in a chandelier overhead.

Ambient + diffuse + specular lighting should capture this scene correctly. The number of light sources affects performance but doesn't call for a different technique.

d) A stage scene that includes a spotlight shining on some props, some of which have a metallic appearance and others of which look painted.

Ambient + diffuse + specular lighting is needed to achieve a metallic appearance. 


5. You're working on an immersive MMO game that uses procedurally generated content to render a world at a grand scale. Unfortunately when you set your far clipping plane to 10,000,000, you notice that faraway objects like distant mountains are sometimes drawn in front of each other where they shouldn't be, even sometimes "popping" back and forth when the player's viewpoint moves.

a) Indicate which of the following is causing the issue and explain how in more detail:

  i. Insufficient Z-buffer precision.

  ii. Z-buffer overflow.

  iii. An orthogonal projection matrix.

  iv. Passing the wrong parameter to glDepthFunc().



The answer is: i. Insufficient Z-buffer precision. Because the far clipping plane is so far away, differences in distance that are much smaller than the clipping plane can get rounded off, causing objects to appear slightly closer or farther than they should. This rounding error changes depending on the direction the player is facing as this changes the depth-in-scene of the objects.



6. You are lighting a haunted house scene using a Phong shading model and a single light source. The ambient, diffuse, and specular intensities for your light source are 0.3, 0.3, and 0.9 respectively.

a) You find that the shadows in your haunted house don't look dark enough, and even places where no light should reach contain easily visible detail. How can you address this problem by changing one of the intensity values of your light source (which intensity should change and should it increase or decrease)?

Decrease the ambient intensity. This will make unlit places appear darker.


b) After making the correction from part (a), you find that the scene is now too dim overall. Which intensity value (other than the one you changed in part (a)) can you change to compensate, and should you increase or decrease it?

You can increase the diffuse value a bit, which will increase the brightness of lit areas of the scene to compensate for the overall brightness reduction caused by decreasing ambient light.



7. You have code that sets up a perspective projection using the following function call:

gluPerspective(90, 1.0, 1.0, 500.0);

Unfortunately, you're tasked with porting the code to an embedded device which has core OpenGL functionality but doesn't have the GLU library. Write an equivalent function call to set up an identical perspective projection matrix that uses glFrustrum instead of gluPerspective.


The aspect ratio is 1.0, so the top/bottom and left/right clipping planes will be set to identical values.

The FoV is 90, so the frustrum will have a right angle at its top, and the near clipping plane is 1.0, so to compute the left/right top/bottom values we can use a 45-45-90 triangle with the 90-degree angle at the middle of the near clipping plane. One leg of this triangle is the 1.0 distance from the near clipping plane to the camera, where the 45-degree angle at that corner bisects the 90-degree FoV. The hypotenuse of this triangle then extends from the camera along one edge of the viewing frustrum to an extreme of the near clipping plane, and the third side of the triangle is on the near clipping plane extending from the edge back to the center. Because this triangle is isosceles, we know that the near clipping plane edge has length 1.0, which makes the near clipping plane a 2x2 square.

glFrustrum(
  -1, 1, // left and right
  -1, 1, // bottom and top
  1, 500 // near and far
);
